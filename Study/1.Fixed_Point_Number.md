# Fixed Point Number

## 왜 필요한가

- HW가 소수점을 인지할 수 있는가 ➡️ ❌
  - HW에서 실수를 표현할 수 있는 방법이 없음
  - HW는 bit로만 수 표현 가능
- HW에 실수를 넣을 땐, 정수로 변환해서 넣어줘야함
  - 변환해준 정수를 **❗사람이 실수로 해석❗**해야함
  - 해석 ➡️ 약속이 필요함
  - 이때, 정수를 실수로 해석하기 위한 약속이 Fixed Point Number

## 어떻게 변환하는가

### Fixed Point Number 표현 방법: Qm.n

- 부호비트 MSB
- 정수부: (m-1)비트
- 소수부: n비트
- Example) Q5.8
  - |MSB|4bit-Integer|8bit-Fraction|

### 변환 방법

양수
---

Ex) 2.7 Q3.4로 변환할 때
1. $2.7*2^4$
   - $실수*2^(Frac Bit)$
   - 실수에 $2^(소수부비트)$를 곱해줌
   - $2.7*2^4=43.2$
2. 나온값을 ```rounding```함
   - 과정1에서 나온 결과를 ```반올림```하여 정수로 만들어줌
   - $43.2-->43$
3. 정수값을 비트로 표현
   - 이 때, Q3.4에 맞게 7비트로 표현(signed)
   - $(43)[Decimal] = (0101011)[Binary]$
4. 해석
   - 부호비트: MSB =0 --> 양수
   - 정수부: 10[binary] == 2[decimal]
   - 실수부: 1011[binary] == 0.6875[decimal]
   - 기존 소수부: 0.7 / 변환 후 소수부: 0.6875
     - ⚠️양자화 과정에서 오차가 발생한다

음수
---

Ex) -1.3 Q3.4로 변환할 때
1. $-1.3*2^4$
   - $실수*2^(Frac Bit)$
   - 실수에 $2^(소수부비트)$를 곱해줌
   - $-1.3*2^4=-20.8$
2. 나온값을 ```rounding```함
   - 과정1에서 나온 결과를 ```반올림```하여 정수로 만들어줌
   - $-20.8-->-21$
3. 정수값을 비트로 표현
   - 이 때, Q3.4에 맞게 7비트로 표현(signed)
   - $(-21)[Decimal] = (1101011)[Binary]$
4. 해석
   - 부호비트: MSB = 1 --> 음수
   - 음수니까 2의 보수를 취함
     - 1101011 --1의보수--> 0010100 --2의보수--> 0010101
   - 정수부: 01[binary] --> 1[decimal]
   - 소수부: 0100[binary] --> 0.25[decimal]
   - 변환 결과: -1.25
 - ⚠️양자화 과정에서 오차가 발생한다

# Fixed Point Number - 사칙 연산

## 덧셈 / 뺄셈 --> 그냥 정수와 동일하게 덧셈 뺄셈 진행하면됨

- 덧셈
  - Qm.n + Qm.n
    - 결과는 Q(m+1).n
      - 소수부의 비트수는 그대로 유지됨
    - 전체 비트 수는 (m+1)+n 비트가 됨
      - 오버플로우 방지 위함
- 뺄셈
  - 그냥 2의 보수로 변환해서 덧셈 진행해주면 됨

## 곱셈 / 나눗셈

- 곱셈
  - Qm.n * Qa.b
    - 결과는 Q(m+a).(n+b)

# Fixed Point Number - Format 변환

## Ex) Q3.16 --> Q1.8로 변환할려면 어떻게 해야할까

- 정수부 / 소수부를 따로 나누어 변환해준다

### 소수부(Truncation방식 사용시)
- 소수부 16비트를 8비트로 바꿔줘야함
- Truncation
  - 최하위 8비트를 그대로 잘라 나머지 8비트를 그대로 소수부로 사용
  - 이렇게하면 정밀도만 떨어짐
    - 0.123456789 --> 0.1234로 바꾼다한들
      - 정밀도만 떨어지지
      - 값이 완전히 바뀌는 것은 아님
      - 정밀도에 의한 오차는 존재함

### 정수부
- 정수부는 Saturation을 해야함
- 정수부 3비트는 -8~7까지 표현가능
- 정수부 1비트는 -1~0까지 표현가능
  - 만일 기존 정수부 3비트가 -1보다 작으면
    - 정수부 1비트는 1로 포화
  - 만일 기존 정수부 3비트가 0보다 크면
    - 정수부 1비트는 0으로 포화

```verilog
//예시
logic signed [2:0] int_3;
logic signed int_1;

always_comb begin
   if(int_3 > 0) begin
      int_1 = 0;
   end
   else if(int_3 < -1) begin
      int_1 = 1;
   end
end
```